-- This script is designed to be run once to set up the initial database schema and policies.
-- It's idempotent, meaning it can be run multiple times without causing errors.

-- 1. Create Tables
-- Note: 'drivers' table stores public profile information for delivery drivers.
-- The 'id' column in 'drivers' is a foreign key referencing 'auth.users.id', linking it to the authentication user.
-- The 'orders' table is designed to hold all delivery jobs, regardless of their status.

create table if not exists public.drivers (
  id uuid not null primary key, -- Corresponds to auth.users.id
  updated_at timestamp with time zone,
  full_name text,
  phone text,
  vehicle_model text,
  license_plate text,
  insurance_verified boolean default false,
  emergency_contact_name text,
  emergency_contact_phone text,
  constraint id foreign key(id) references auth.users(id) on delete cascade
);

create table if not exists public.orders (
    id bigint generated by default as identity primary key,
    created_at timestamp with time zone default now() not null,
    title text,
    pickup_address text,
    destination_address text,
    pickup_coordinates geography(Point, 4326),
    destination_coordinates geography(Point, 4326),
    distance text,
    time text,
    payout numeric,
    currency text,
    stops integer default 1,
    status text default 'Pending'::text not null, -- e.g., Pending, Confirmed, Picked Up, Delivered, Cancelled
    driver_id uuid,
    delivery_type text default 'courier'::text,
    constraint driver_id foreign key(driver_id) references auth.users(id) on delete set null
);

-- 2. Enable Row Level Security (RLS)
-- RLS is a critical security feature of PostgreSQL. It ensures that users can only access and modify data they are permitted to.
-- ALWAYS enable RLS on tables that contain sensitive data.

alter table public.drivers enable row level security;
alter table public.orders enable row level security;

-- 3. Create RLS Policies
-- Policies define the rules for accessing data. Without any policies, all access to a table with RLS enabled is denied by default.

-- USERS
drop policy if exists "Authenticated users can view all user profiles." on public.drivers;
create policy "Authenticated users can view all user profiles."
on public.drivers for select
to authenticated
using (true);

drop policy if exists "Users can create their own driver profile." on public.drivers;
create policy "Users can create their own driver profile."
on public.drivers for insert
to authenticated
with check (auth.uid() = id);

drop policy if exists "Users can update their own profile." on public.drivers;
create policy "Users can update their own profile."
on public.drivers for update
to authenticated
using (auth.uid() = id)
with check (auth.uid() = id);

-- ORDERS
drop policy if exists "Drivers can view available courier jobs." on public.orders;
create policy "Drivers can view available courier jobs."
on public.orders for select
to authenticated
using ( (status = 'Confirmed'::text) and (delivery_type = 'courier'::text) );

drop policy if exists "Drivers can view their own assigned jobs." on public.orders;
create policy "Drivers can view their own assigned jobs."
on public.orders for select
to authenticated
using (auth.uid() = driver_id);

drop policy if exists "Drivers can accept an available job." on public.orders;
create policy "Drivers can accept an available job."
on public.orders for update
to authenticated
using ( (status = 'Confirmed'::text) and (delivery_type = 'courier'::text) and (driver_id is null) )
with check (auth.uid() = driver_id);

drop policy if exists "Drivers can update the status of their own accepted job." on public.orders;
create policy "Drivers can update the status of their own accepted job."
on public.orders for update
to authenticated
using (auth.uid() = driver_id)
with check (auth.uid() = driver_id);


-- 4. Create a trigger and function to auto-create a driver profile on new user signup
-- This function is called whenever a new user is added to 'auth.users'.
-- It inserts a corresponding profile row into 'public.drivers'.
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.drivers (id, full_name, email)
  values (new.id, new.raw_user_meta_data->>'full_name', new.email);
  return new;
end;
$$;

-- This trigger executes the 'handle_new_user' function after a new user is inserted.
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();


-- Note on Supabase Storage:
-- If your app needs to handle file uploads (e.g., driver profile pictures), you would also set up
-- policies for Supabase Storage buckets here. For this app, we are not using Storage yet.

-- Example Storage Policy (if needed later):
-- create policy "Driver images are publicly accessible."
-- on storage.objects for select
-- using ( bucket_id = 'driver_avatars' );

-- create policy "Anyone can upload a driver avatar."
-- on storage.objects for insert
-- with check ( bucket_id = 'driver_avatars' );
